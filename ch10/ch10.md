## System-Level I/O

### Unix I/O

- All I/O devices, such as networks, disks, and terminals, are modeled as files, and all input and output is performed by reading and writing the appropriate files
- This enables all input and output to be performed in a uniform and consistent way:
  - **Opening files**:
    - The kernel returns a small nonnegative integer, called a descriptor, that identifies the file in all subsequent operations on the file
    - The kernel keeps track of all information about the open file
    - The application only keeps track of the descriptor
    - Each process created by a Linux shell begins life with three open files:
      - standard input (descriptor 0)
      - standard output (descriptor 1)
      - standard error (descriptor 2)

  - **Changing the current file position**: 
    - The kernel maintains a file position k, initially 0, for each open file
    - An application can set the current file position k explicitly by performing a `seek` operation
  
  - **Reading and writing files**:
    - A read operation copies n > 0 bytes from a file to memory, starting at the current file position k and then incrementing k by n
    - A write operation copies n > 0 bytes from memory to a file, starting at the current file position k and then updating k
    - performing a read operation when k ≥ m triggers a condition known as end-of-file (EOF), which can be detected by the application
  
  - **Closing files**:
    - When a process terminates for any reason, the kernel closes all open files and frees their memory resources

### Files

- Each Linux file has a type that indicates its role in the system:
  - A regular file contains arbitrary data
  - A directory is a file consisting of an array of links, where each link maps a filename to a file, which may be another directory
  - A socket is a file that is used to communicate with another process across a network

- Each process has a current working directory that identifies its current location in the directory hierarchy (can use `cd` command to change in shell)

- An absolute pathname starts with a slash and denotes a path from the root node
- A relative pathname starts with a filename and denotes a path from the current working directory

### Opening and Closing Files

- A process **opens an existing file** or **creates a new file** by calling the open function:

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// Returns: new file descriptor if OK, −1 on error
int open(char *filename, int flags, mode_t mode);
```

- The `open` function converts a filename to a file descriptor and returns the descriptor number

- The descriptor returned is always the smallest descriptor that is not currently open in the process. The flags argument indicates how the process intends to access the file:

```c
O_RDONLY. Reading only
O_WRONLY. Writing only
O_RDWR. Reading and writing
```

- A process closes an open file by calling the close function:

```c
#include <unistd.h>

// Returns: 0 if OK, −1 on error
int close(int fd);
```

- Closing a descriptor that is already closed is an error

### Reading and Writing Files

- Applications perform input and output by calling the read and write functions, respectively:

```c
#include <unistd.h>

// Returns: number of bytes read if OK, 0 on EOF, −1 on error
ssize_t read(int fd, void *buf, size_t n);

// Returns: number of bytes written if OK, −1 on error
ssize_t write(int fd, const void *buf, size_t n);
```

- The read function copies at most `n` bytes from the current file position of descriptor `fd` to memory location `buf`
- The write function copies at most `n` bytes from memory location `buf` to the current file position of descriptor `fd`
- A program that uses read and write calls to copy the standard input to the standard output, 1 byte at a time:
- On x86-64 systems, a size_t is defined as an unsigned long, and an ssize_t (signed size) is defined as a long

```c
#include "csapp.h"

int main(void) {
  char c;
  while(Read(STDIN_FILENO, &c, 1) != 0)
    Write(STDOUT_FILENO, &c, 1);
  exit(0);
}
```

- In some situations, read and write transfer fewer bytes than the application requests. Such short counts do not indicate an error. They occur for a number of reasons:
  - **Encountering EOF on reads**
  - **Reading text lines from a terminal**
  - **Reading and writing network sockets**
