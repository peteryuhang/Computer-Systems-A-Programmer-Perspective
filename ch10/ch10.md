## System-Level I/O

### Unix I/O

- All I/O devices, such as networks, disks, and terminals, are modeled as files, and all input and output is performed by reading and writing the appropriate files
- This enables all input and output to be performed in a uniform and consistent way:
  - **Opening files**:
    - The kernel returns a small nonnegative integer, called a descriptor, that identifies the file in all subsequent operations on the file
    - The kernel keeps track of all information about the open file
    - The application only keeps track of the descriptor
    - Each process created by a Linux shell begins life with three open files:
      - standard input (descriptor 0)
      - standard output (descriptor 1)
      - standard error (descriptor 2)

  - **Changing the current file position**: 
    - The kernel maintains a file position k, initially 0, for each open file
    - An application can set the current file position k explicitly by performing a `seek` operation
  
  - **Reading and writing files**:
    - A read operation copies n > 0 bytes from a file to memory, starting at the current file position k and then incrementing k by n
    - A write operation copies n > 0 bytes from memory to a file, starting at the current file position k and then updating k
    - performing a read operation when k â‰¥ m triggers a condition known as end-of-file (EOF), which can be detected by the application
  
  - **Closing files**:
    - When a process terminates for any reason, the kernel closes all open files and frees their memory resources


