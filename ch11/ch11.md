## Network Programming

### The Client-Server Programming Model

- It is important to realize that clients and servers are processes and not machines, or hosts as they are often called in this context

![](./client_server_transaction.png)

### Networks

- Hardware organization:

![](./hardare_organization_of_a_network_host.png)

- Data received from the network are copied from the adapter across the I/O and memory buses into memory, typically by a DMA transfer

- An **Ethernet segment** consists of some wires (usually twisted pairs of wires) and a small box called a **hub**:

![](./ethernet_segment.png)

- Every host adapter sees the frame, but only the destination host actually reads it
- Multiple Ethernet segments can be connected into larger LANs, called **bridged Ethernets**, using a set of wires and small boxes called bridges:

![](./bridged_ethernet_segment.png)

- Using a clever distributed algorithm, they automatically learn over time which hosts are reachable from which ports and then selectively copy frames from one port to another only when it is necessary

- At a higher level in the hierarchy, multiple incompatible LANs can be connected by specialized computers called routersto form an internet (interconnected network)

- The crucial property of an internet is that it can consist of different LANs and WANs with radically different and incompatible technologies:

![](./a_small_internet.png)

- How hosts and routers use the internet protocol to transfer data across incompatible LANs:

![](./how_data_travel_from_one_host_to_another_on_an_internet.png)

### The Global IP Internet

- Hardware and software organization of an internet application

![](./hardare_organization_of_a_network_host.png)

- The sockets functions are typically implemented as system calls that trap into the kernel and call various kernel-mode functions in TCP/IP
- The IP mechanism is unreliable in the sense that it makes no effort to recover if datagrams are lost or duplicated in the network
- UDP (Unreliable Datagram Protocol) extends IP slightly, so that datagrams can be transferred from process to process, rather than host to host
- TCP is a complex protocol that builds on IP to provide reliable full duplex (bidirectional) connections between processes

#### IP Addresses

- Network programs store IP addresses in the IP address structure:

```c
/* IP address structure */
struct in_addr {
  uint32_t s_addr; /* Address in network byte order (big-endian) */
};
```

- It would make more sense to define a scalar type for IP addresses, but it is too late to change now because of the enormous installed base of applications
- TCP/IP defines a uniform network byte order (big-endian byte order) for any integer data item
- Unix provides the following functions for converting between network and host byte order:

```c
#include <arpa/inet.h>

// Returns: value in network byte order
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);

// Returns: value in host byte order
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
```

- eg. `128.2.194.242` is the dotted-decimal representation of the address `0x8002c2f2`
- Application programs can convert back and forth between IP addresses and dotted-decimal strings using the functions `inet_pton` and `inet_ntop`

```c
#include <arpa/inet.h>

// Returns: 1 if OK, 0 if src is invalid dotted decimal, −1 on error
int inet_pton(AF_INET, const char *src, void *dst);

// Returns: pointer to a dotted-decimal string if OK, NULL on error
const char *inet_ntop(AF_INET, const void *src, char *dst, socklen_t size);
```

#### Internet Domain Names

- The set of domain names forms a hierarchy, and each domain name encodes its position in the hierarchy
- The nodes of the tree represent domain names that are formed by the path back to the root

![](./subset_of_the_internet_domain_name_hierarchy.png)

- The Internet defines a mapping between the set of domain names and the set of IP addresses
- Linux nslookup program, which displays the IP addresses associated with a domain name, eg.

```bash
linux> nslookup localhost
Address: 127.0.0.1
```

#### Internet Connections

- A socket is an end point of a connection
- Each socket has a corresponding socket address that consists of an Internet address and a 16-bit integer port and is denoted by the notation address:port
- The mapping between well-known names and well-known ports is contained in a file called `/etc/services`
- A connection is uniquely identified by the socket addresses of its two end points. This pair of socket addresses is known as a socket pair and is denoted by the tuple:

```
(cliaddr:cliport, servaddr:servport)
```

![](./anatomy_of_an_internet_connection.png)

### The Sockets Interface

- The **sockets interface** is a set of functions that are used in conjunction with the Unix I/O functions to build network applications

![](./sockets_interface_structure.png)

- Socket address structures:

```c
/* IP socket address structure */
struct sockaddr_in {
  uint16_t sin_family; /* Protocol family (always AF_INET) */
  uint16_t sin_port; /* Port number in network byte order */
  struct in_addr sin_addr; /* IP address in network byte order */
  unsigned char sin_zero[8]; /* Pad to sizeof(struct sockaddr) */
};

/* Generic socket address structure (for connect, bind, and accept) */
struct sockaddr {
  uint16_t sa_family; /* Protocol family */
  char sa_data[14]; /* Address data */
};
```

- The `_in` suffix is short for internet, not input

#### Socket Address Structures

- The IP address and port number are always stored in network (big-endian) byte order

- Clients and servers use the socket function to create a **socket descriptor**:

```c
#include <sys/types.h>
#include <sys/socket.h>

// Returns: nonnegative descriptor if OK, −1 on error
int socket(int domain, int type, int protocol);
```

- eg. `clientfd = Socket(AF_INET, SOCK_STREAM, 0);`
- The clientfd descriptor returned by socket is only partially opened and cannot yet be used for reading and writing

- A client establishes a connection with a server by calling the **connect function**:

```c
#include <sys/socket.h>

// Returns: 0 if OK, −1 on error
int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);
```

- If successful, the clientfd descriptor is now ready for reading and writing, and the resulting connection is characterized by the socket pair `(x:y, addr.sin_addr:addr.sin_port)`

- The **bind function** asks the kernel to associate the server’s socket address in addr with the socket descriptor sockfd:

```c
#include <sys/socket.h>

// Returns: 0 if OK, −1 on error
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

- Client -> Active(initiate) -> connect
- Server -> Passive(wait) -> listen

- A server calls the listen function to tell the kernel that the descriptor will be used by a server instead of a client:

```c
#include <sys/socket.h>

// Returns: 0 if OK, −1 on error
int listen(int sockfd, int backlog);
```

- The listen function converts sockfd from an active socket to a listening socket that can accept connection requests from clients
- The backlog argument is a hint about the number of outstanding connection requests that the kernel should queue up before it starts to refuse requests

- Servers wait for connection requests from clients by calling the **accept function**:

```c
#include <sys/socket.h>

// Returns: nonnegative connected descriptor if OK, −1 on error
int accept(int listenfd, struct sockaddr *addr, int *addrlen);
```

- The listening descriptor serves as an end point for client connection requests. It is typically created once and exists for the lifetime of the server
- The roles of the listening and connected descriptors:

![](./the_roles_of_the_listening_and_connected_descriptors.png)

- Why the distinction between listening and connected descriptors?
  - Bcause it allows us to build concurrent servers that can process many client connections simultaneously

#### Host and Service Conversion

- When used in conjunction with the sockets interface, they allow us to write network programs that are independent of any particular version of the IP protocol

- The `getaddrinfo` Function (string -> socket struct), async-safe

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

// Returns: 0 if OK, nonzero error code on error
int getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct addrinfo **result);

// Returns: nothing
void freeaddrinfo(struct addrinfo *result);

// Returns: error message
const char *gai_strerror(int errcode);
```

- Given host and service (the two components of a socket address), getaddrinfo returns a result that points to a linked list of addrinfo structures, each of which points to a socket address structure that corresponds to host and service:

![](./data_structure_returned_by_getaddrinfo.png)

- After a client calls getaddrinfo, it walks this list, trying each socket address in turn until the calls to socket and connect succeed and the connection is established
- Similarly, a server tries each socket address on the list until the calls to socket and bind succeed and the descriptor is bound to a valid socket address

- When passed as a hints argument, only the ai_family, ai_socktype, ai_protocol, and ai_flags fields can be set. The other fields must be set to zero (or NULL)
- The addrinfo structure used by getaddrinfo:

```c
struct addrinfo {
  int ai_flags; /* Hints argument flags */
  int ai_family; /* First arg to socket function */
  int ai_socktype; /* Second arg to socket function */
  int ai_protocol; /* Third arg to socket function */
  char *ai_canonname; /* Canonical hostname */
  size_t ai_addrlen; /* Size of ai_addr struct */
  struct sockaddr *ai_addr; /* Ptr to socket address structure */
  struct addrinfo *ai_next; /* Ptr to next item in linked list */
};
```

- This powerful property allows us to write clients and servers that are independent of any particular version of the IP protocol

- The `getnameinfo` Function (socket struct -> string), async-safe:

```c
#include <sys/socket.h>
#include <netdb.h>

// Returns: 0 if OK, nonzero error code on error
int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *service, size_t servlen, int flags);
```

- The getnameinfo function converts the socket address structure `sa` to the corresponding host and service name strings and copies them to the host and service buffers
- Simple program, called hostinfo, that uses getaddrinfo and getnameinfo to display the mapping of a domain name to its associated IP addresses (similar to NSLOOKUP):

```c
#include "csapp.h"

int main(int argc, char **argv) {
  struct addrinfo *p, *listp, hints;
  char buf[MAXLINE];
  int rc, flags;
  if (argc != 2) {
    fprintf(stderr, "usage: %s <domain name>\n", argv[0]);
    exit(0);
  }

  /* Get a list of addrinfo records */
  memset(&hints, 0, sizeof(struct addrinfo));
  hints.ai_family = AF_INET; /* IPv4 only */
  hints.ai_socktype = SOCK_STREAM; /* Connections only */
  if ((rc = getaddrinfo(argv[1], NULL, &hints, &listp)) != 0) {
    fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(rc));
    exit(1);
  }

  /* Walk the list and display each IP address */
  flags = NI_NUMERICHOST; /* Display address string instead of domain name */
  for (p = listp; p; p = p->ai_next) {
    Getnameinfo(p->ai_addr, p->ai_addrlen, buf, MAXLINE, NULL, 0, flags);
    printf("%s\n", buf);
  }

  /* Clean up */
  Freeaddrinfo(listp);
  exit(0);
}
```

#### Helper Functions for the Sockets Interface

- A client establishes a connection with a server by calling **open_clientfd**:

```c
#include "csapp.h"

// Returns: descriptor if OK, −1 on error
int open_clientfd(char *hostname, char *port);
```

- implementation:

```c
int open_clientfd(char *hostname, char *port) {
  int clientfd;
  struct addrinfo hints, *listp, *p;

  /* Get a list of potential server addresses */
  memset(&hints, 0, sizeof(struct addrinfo));
  hints.ai_socktype = SOCK_STREAM; /* Open a connection */
  hints.ai_flags = AI_NUMERICSERV; /* ... using a numeric port arg. */
  hints.ai_flags |= AI_ADDRCONFIG; /* Recommended for connections */
  Getaddrinfo(hostname, port, &hints, &listp);

  /* Walk the list for one that we can successfully connect to */
  for (p = listp; p; p = p->ai_next) {
    /* Create a socket descriptor */
    if ((clientfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
      continue; /* Socket failed, try the next */

    /* Connect to the server */
    if (connect(clientfd, p->ai_addr, p->ai_addrlen) != -1)
      break; /* Success */
    Close(clientfd); /* Connect failed, try another */
  }

  /* Clean up */
  Freeaddrinfo(listp);
  if (!p) /* All connects failed */
    return -1;
  else /* The last connect succeeded */
    return clientfd;
}
```

- A server creates a listening descriptor that is ready to receive connection requests by calling the **open_listenfd function**:

```c
#include "csapp.h"

// Returns: descriptor if OK, −1 on error
int open_listenfd(char *port);
```

- implementation:

```c
int open_listenfd(char *port) {
  struct addrinfo hints, *listp, *p;
  int listenfd, optval=1;

  /* Get a list of potential server addresses */
  memset(&hints, 0, sizeof(struct addrinfo));
  hints.ai_socktype = SOCK_STREAM; /* Accept connections */
  hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* ... on any IP address */
  hints.ai_flags |= AI_NUMERICSERV; /* ... using port number */
  Getaddrinfo(NULL, port, &hints, &listp);

  /* Walk the list for one that we can bind to */
  for (p = listp; p; p = p->ai_next) {
    /* Create a socket descriptor */
    if ((listenfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
      continue; /* Socket failed, try the next */

    /* Eliminates "Address already in use" error from bind */
    Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,
    (const void *)&optval , sizeof(int));

    /* Bind the descriptor to the address */
    if (bind(listenfd, p->ai_addr, p->ai_addrlen) == 0)
      break; /* Success */
    Close(listenfd); /* Bind failed, try the next */
  }

  /* Clean up */
  Freeaddrinfo(listp);
  if (!p) /* No address worked */
    return -1;

  /* Make it a listening socket ready to accept connection requests */
  if (listen(listenfd, LISTENQ) < 0) {
    Close(listenfd);
    return -1;
  }

  return listenfd;
}
```
